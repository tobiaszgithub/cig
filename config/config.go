package config

import (
	"encoding/json"
	"errors"
	"fmt"
	"log"
	"os"
	"path/filepath"
)

type ConfigurationFile struct {
	ActiveTenantKey string          `json:"activeTenantKey"`
	Tenants         []Configuration `json:"tenants"`
}

type AutoGenerated struct {
	ActiveTenantKey string `json:"activeTenantKey"`
	Tenants         []struct {
		Key           string `json:"key"`
		APIURL        string `json:"apiURL"`
		Authorization struct {
			Type         string `json:"type"`
			Username     string `json:"username"`
			Password     string `json:"password"`
			ClientID     string `json:"clientID"`
			ClientSecret string `json:"clientSecret"`
			TokenURL     string `json:"tokenURL"`
		} `json:"authorization"`
	} `json:"tenants"`
}

type Configuration struct {
	Key           string        `json:"key"`
	ApiURL        string        `json:"apiURL"`
	Authorization Authorization `json:"authorization"`
}
type Authorization struct {
	Type         string `json:"type"`
	Username     string `json:"username"`
	Password     string `json:"password"`
	ClientID     string `json:"clientID"`
	ClientSecret string `json:"clientSecret"`
	TokenURL     string `json:"tokenURL"`
}

func NewConfiguration() (Configuration, error) {
	conf := Configuration{}

	// path, _ := os.Getwd()
	// println("os.Getwd(): ", path)

	configFile, err := os.Open("./config.json")
	if err != nil {
		homePath, _ := os.UserHomeDir()
		configFilePath := filepath.Join(homePath, ".cig", "config.json")
		log.Println("Config file path: ", configFilePath)
		configFile, err = os.Open(configFilePath)
		if err != nil {
			err = fmt.Errorf("error opening config.json: %w", err)
			return conf, err
		}

	}

	defer configFile.Close()

	confAll := ConfigurationFile{}

	err = json.NewDecoder(configFile).Decode(&confAll)
	if err != nil {
		return conf, err
	}
	for _, v := range confAll.Tenants {
		if confAll.ActiveTenantKey == v.Key {
			conf.Key = v.Key
			conf.ApiURL = v.ApiURL
			conf.Authorization.Type = v.Authorization.Type
			conf.Authorization.Username = v.Authorization.Username
			conf.Authorization.Password = v.Authorization.Password
			conf.Authorization.ClientID = v.Authorization.ClientID
			conf.Authorization.ClientSecret = v.Authorization.ClientSecret
			conf.Authorization.TokenURL = v.Authorization.TokenURL
			break
		}
	}

	if conf.ApiURL == "" {

		err = errors.New("provide configuration file with tenant ApiURL")
		return conf, err
	}

	return conf, err
}

func GenerateEmptyConfigFile(fileName string) error {
	conf := ConfigurationFile{}

	configFile, err := os.OpenFile(fileName, os.O_RDWR|os.O_CREATE|os.O_EXCL, 0666)
	if err != nil {
		return err
	}

	conf.ActiveTenantKey = "dev-basic"
	basicConfig := Configuration{
		Key:    "dev-basic",
		ApiURL: "https://yourtenat.hci.eu2.hana.ondemand.com/api/v1",
		Authorization: Authorization{
			Type:     "basic",
			Username: "username",
			Password: "password",
		},
	}
	conf.Tenants = append(conf.Tenants, basicConfig)

	oauthConfig := Configuration{
		Key:    "dev-oauth",
		ApiURL: "https://yourtenat.hci.eu2.hana.ondemand.com/api/v1",
		Authorization: Authorization{
			Type:         "oauth",
			ClientID:     "clientID",
			ClientSecret: "clientSecret",
			TokenURL:     "https://youttokenurl.hana.ondemand.com/oauth/token",
		},
	}
	conf.Tenants = append(conf.Tenants, oauthConfig)

	defer configFile.Close()

	enc := json.NewEncoder(configFile)
	enc.SetIndent("", "\t")

	err = enc.Encode(conf)
	if err != nil {
		return err
	}

	return nil

}
